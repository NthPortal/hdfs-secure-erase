package com.nthportal.hadoop.hdfs.erase.core.specs;

import com.google.common.base.Preconditions;
import org.apache.commons.codec.binary.Hex;

import javax.annotation.Nullable;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Provides bytes (for use by {@link OverwriteSpec}).
 */
public abstract class ByteProvider {
    /**
     * Generates bytes.
     *
     * <p>The byte array passed in is guaranteed to be filled with zeros.
     *
     * @param bytes the array to fill with bytes
     * @param state the {@link State state} of this provider after generating
     *              bytes (may be ignored if there is no relevant state to store)
     * @return the {@link Reusability} of the generated bytes
     */
    public abstract Reusability nextBytes(byte[] bytes, State state);

    /**
     * Returns a short description of the bytes provided by this {@code ByteProvider}.
     *
     * @return a short description of the bytes provided by this ByteProvider
     */
    public String description() {
        return "unidentified bytes";
    }

    /**
     * Returns a ByteProvider which generates random bytes using a {@link SecureRandom}.
     *
     * @return a ByteProvider which generates random bytes using a SecureRandom
     */
    public static ByteProvider randomBytes() {
        return randomBytes(new SecureRandom());
    }

    /**
     * Returns a ByteProvider which generates random bytes using
     * the specified {@link SecureRandom}.
     *
     * @param random the SecureRandom to use to generate bytes
     * @return a ByteProvider which generates random bytes using
     * the specified SecureRandom
     * @throws NullPointerException if the SecureRandom is null
     */
    public static ByteProvider randomBytes(final SecureRandom random) throws NullPointerException {
        Preconditions.checkNotNull(random);

        return new ByteProvider() {
            @Override
            public Reusability nextBytes(byte[] bytes, State state) {
                random.nextBytes(bytes);
                return Reusability.NONE;
            }

            @Override
            public String description() {
                return "random bytes";
            }
        };
    }

    /**
     * Returns a ByteProvider which provides {@code 0}-value bytes (bytes with the value {@code 0}).
     *
     * @return a ByteProvider which provides 0-value bytes
     */
    public static ByteProvider zeros() {
        return new ByteProvider() {
            @Override
            public Reusability nextBytes(byte[] bytes, State state) {
                // Abuse the fact that `bytes` is specified to be filled with zeros
                return Reusability.PREFIX_UNLIMITED;
            }

            @Override
            public String description() {
                return "zeros (0x00)";
            }
        };
    }

    /**
     * Returns a ByteProvider which provides bytes with a specified value.
     *
     * @param b the byte value to provide
     * @return a ByteProvider which provides bytes with the specified value
     */
    public static ByteProvider repeatedBytes(final byte b) {
        if (b == 0) {
            return zeros();
        } else {
            return new ByteProvider() {
                @Override
                public Reusability nextBytes(byte[] bytes, State state) {
                    Arrays.fill(bytes, b);
                    return Reusability.PREFIX_UNLIMITED;
                }

                @Override
                public String description() {
                    return "byte (0x" + Hex.encodeHexString(new byte[] {b}) + ")";
                }
            };
        }
    }

    /**
     * Returns a ByteProvider which provides a repeated pattern of bytes.
     *
     * @param toRepeat the bytes to repeat
     * @return a ByteProvider which provides a repeated pattern of bytes
     * @throws NullPointerException if the byte array is null
     * @throws IllegalArgumentException if the byte array is empty
     */
    public static ByteProvider repeatedBytes(final byte[] toRepeat)
            throws NullPointerException, IllegalArgumentException {
        Preconditions.checkNotNull(toRepeat);
        Preconditions.checkArgument(toRepeat.length > 0, "Byte array must be non-empty");

        // Simplify provider if array is of size 1
        if (toRepeat.length == 1) {
            return repeatedBytes(toRepeat[0]);
        }

        return new ByteProvider() {
            @Override
            public Reusability nextBytes(byte[] bytes, State state) {
                // Handle offset from previous operation
                int offsetIndex = state.getInt();
                int initialSrcLen = toRepeat.length - offsetIndex;

                // Bytes to provide are less than the remaining bytes in toRepeat
                if (bytes.length < initialSrcLen) {
                    System.arraycopy(toRepeat, offsetIndex, bytes, 0, bytes.length);
                    state.setInt(offsetIndex + bytes.length);
                    return Reusability.NONE;
                }

                // Copy remnant of toRepeat from previous operation
                System.arraycopy(toRepeat, offsetIndex, bytes, 0, initialSrcLen);

                int effectiveDestLen = bytes.length - offsetIndex;

                // Repeat toRepeat as needed to fill the rest of bytes
                if (effectiveDestLen < toRepeat.length) {
                    System.arraycopy(toRepeat, 0, bytes, offsetIndex, effectiveDestLen);
                    state.setInt(effectiveDestLen);
                    return (effectiveDestLen == offsetIndex) ? Reusability.EXACT : Reusability.NONE;
                } else {
                    System.arraycopy(toRepeat, 0, bytes, offsetIndex, toRepeat.length);

                    int currentLength = toRepeat.length;
                    while (currentLength < effectiveDestLen) {
                        System.arraycopy(bytes, offsetIndex, bytes, offsetIndex + currentLength, Math.min(currentLength, effectiveDestLen - currentLength));
                        currentLength *= 2;
                    }

                    int newIndex = effectiveDestLen % toRepeat.length;
                    state.setInt(newIndex);
                    return (newIndex == offsetIndex) ? Reusability.EXACT : Reusability.NONE;
                }
            }

            @Override
            public String description() {
                return "byte pattern (0x" + Hex.encodeHexString(toRepeat) + ")";
            }
        };
    }

    /**
     * Stores the state of a {@link ByteProvider} (for example, the last
     * byte or bytes provided).
     */
    public static final class State {
        private final Map<Class<?>, Object> objects = new HashMap<>();
        private int index = 0;

        private State() {}

        /**
         * Returns an index representing the state of the {@code ByteProvider}.
         *
         * <p>If the index was not set, then this method returns 0.
         *
         * @return an index representing the state of the ByteProvider
         */
        public int getInt() {
            return index;
        }

        /**
         * Stores an index representing the state of the {@code ByteProvider}.
         *
         * @param index the index representing the state of the ByteProvider
         */
        public void setInt(int index) {
            this.index = index;
        }

        /**
         * Returns an object representing the state of the {@code ByteProvider}.
         *
         * <p>If an object of the specified class was not previously set, then
         * this method returns {@code null}.
         *
         * @param clazz the class of the object to get
         * @param <T> the type of the object to get
         * @return an object representing the state of the ByteProvider
         */
        @Nullable
        public <T> T getObject(Class<T> clazz) {
            return clazz.cast(objects.get(clazz));
        }

        /**
         * Stores an object representing the state of the {@code ByteProvider}.
         *
         * @param clazz the class of the object to store
         * @param obj the object representing the state of ByteProvider
         * @param <T> the type of the object to store
         * @throws NullPointerException if the object is null
         */
        public <T> void setObject(Class<T> clazz, T obj) throws NullPointerException {
            Preconditions.checkNotNull(clazz);
            Preconditions.checkNotNull(obj);
            objects.put(clazz, obj);
        }

        /**
         * Returns a new, empty {@code State}.
         *
         * @return a new, empty State
         */
        public static State empty() {
            return new State();
        }
    }

    /**
     * Describes the reusability of bytes provided by
     * {@link ByteProvider#nextBytes(byte[], State)}.
     */
    enum Reusability {
        /**
         * The bytes provided are not reusable in any way, and should
         * be discarded after a single use.
         */
        NONE,
        /**
         * The bytes provided are reusable an unlimited number of times, as follows:
         *
         * <ul>
         *     <li>only if reused with the exact same number of bytes</li>
         *     <li>not after other bytes or a different number of bytes are used</li>
         * </ul>
         */
        EXACT,
        /**
         * The bytes provided or any prefix of them (a subarray starting from the beginning of
         * the bytes) may be reused an unlimited number of times.
         */
        PREFIX_UNLIMITED
    }
}
