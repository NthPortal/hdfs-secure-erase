package tmp.namespace.undecided.core.specs;

import com.google.common.base.Preconditions;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

/**
 * Provides bytes (for use by {@link OverwriteSpec}).
 *
 * @see ByteProviders
 */
public interface ByteProvider {
    /**
     * Generates bytes.
     *
     * <p>The byte array passed in is guaranteed to be filled with zeros.
     *
     * @param bytes the array to fill with bytes
     * @param state the {@link State state} of this provider after generating
     *              bytes (may be ignored if there is no relevant state to store)
     * @return the {@link Reusability} of the generated bytes
     */
    Reusability nextBytes(byte[] bytes, State state);

    /**
     * Stores the state of a {@link ByteProvider} (for example, the last
     * byte or bytes provided).
     */
    final class State {
        private final Map<Class<?>, Object> objects = new HashMap<>();
        private int index = 0;

        private State() {}

        /**
         * Returns an index representing the state of the {@code ByteProvider}.
         *
         * <p>If the index was not set, then this method returns 0.
         *
         * @return an index representing the state of the ByteProvider
         */
        public int getInt() {
            return index;
        }

        /**
         * Stores an index representing the state of the {@code ByteProvider}.
         *
         * @param index the index representing the state of the ByteProvider
         */
        public void setInt(int index) {
            this.index = index;
        }

        /**
         * Returns an object representing the state of the {@code ByteProvider}.
         *
         * <p>If an object of the specified class was not previously set, then
         * this method returns {@code null}.
         *
         * @param clazz the class of the object to get
         * @param <T> the type of the object to get
         * @return an object representing the state of the ByteProvider
         */
        @Nullable
        public <T> T getObject(Class<T> clazz) {
            return clazz.cast(objects.get(clazz));
        }

        /**
         * Stores an object representing the state of the {@code ByteProvider}.
         *
         * @param clazz the class of the object to store
         * @param obj the object representing the state of ByteProvider
         * @param <T> the type of the object to store
         * @throws NullPointerException if the object is null
         */
        public <T> void setObject(Class<T> clazz, T obj) throws NullPointerException {
            Preconditions.checkNotNull(clazz);
            Preconditions.checkNotNull(obj);
            objects.put(clazz, obj);
        }

        /**
         * Returns a new, empty {@code State}.
         *
         * @return a new, empty State
         */
        static State empty() {
            return new State();
        }
    }

    /**
     * Describes the reusability of bytes provided by
     * {@link ByteProvider#nextBytes(byte[], State)}.
     */
    enum Reusability {
        /**
         * The bytes provided are not reusable in any way, and should
         * be discarded after a single use.
         */
        NONE,
        /**
         * The bytes provided are reusable an unlimited number of times, as follows:
         *
         * <ul>
         *     <li>only if reused with the exact same number of bytes</li>
         *     <li>not after other bytes or a different number of bytes are used</li>
         * </ul>
         */
        EXACT,
        /**
         * The bytes provided or any prefix of them (a subarray starting from the beginning of
         * the bytes) may be reused an unlimited number of times.
         */
        PREFIX_UNLIMITED
    }
}
